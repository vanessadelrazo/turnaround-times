# app.R - Enhanced Shiny App to Extract Submission and Acceptance Dates from PubMed Central

# Load required libraries
library(shiny)
library(rentrez)
library(xml2)
library(dplyr)
library(DT)
library(ggplot2)
library(lubridate)

# UI definition
ui <- fluidPage(
  # Enhanced CSS for modern aesthetic design
  tags$head(
    tags$style(HTML("
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
      
      * {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }
      
      body {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
      }
      
      .container-fluid {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        margin: 20px;
        padding: 0;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }
      
      /* Enhanced Header */
      .main-header {
        background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
        color: white;
        padding: 40px 30px;
        text-align: center;
        position: relative;
        overflow: hidden;
      }
      
      .main-header::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
        animation: float 6s ease-in-out infinite;
      }
      
      @keyframes float {
        0%, 100% { transform: translateY(0px) rotate(0deg); }
        50% { transform: translateY(-20px) rotate(180deg); }
      }
      
      .main-title {
        font-size: 2.5rem;
        font-weight: 700;
        margin: 0;
        text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        position: relative;
        z-index: 2;
      }
      
      .main-subtitle {
        font-size: 1.1rem;
        font-weight: 300;
        margin-top: 10px;
        opacity: 0.9;
        position: relative;
        z-index: 2;
      }
      
      /* Enhanced Sidebar */
      .col-sm-4 {
        background: linear-gradient(to bottom, #f8f9fa, #e9ecef);
        padding: 30px;
        border-right: 1px solid #dee2e6;
      }
      
      .sidebar-section {
        background: white;
        border-radius: 15px;
        padding: 25px;
        margin-bottom: 20px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        border: 1px solid #e1e5e9;
      }
      
      .sidebar-section h4 {
        color: #2c3e50;
        font-weight: 600;
        margin-bottom: 15px;
        font-size: 1.1rem;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      /* Enhanced Form Controls */
      .form-group label {
        font-weight: 500;
        color: #2c3e50;
        margin-bottom: 8px;
        font-size: 0.95rem;
      }
      
      .form-control {
        border: 2px solid #e1e5e9;
        border-radius: 10px;
        padding: 12px 15px;
        font-size: 0.95rem;
        transition: all 0.3s ease;
        background: #fafbfc;
      }
      
      .form-control:focus {
        border-color: #3498db;
        box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        background: white;
      }
      
      textarea.form-control {
        resize: vertical;
        min-height: 120px;
        font-family: 'Monaco', 'Consolas', monospace;
        line-height: 1.6;
      }
      
      /* Enhanced Radio Buttons */
      .radio-group {
        display: flex;
        gap: 15px;
        margin: 15px 0;
      }
      
      .radio-option {
        position: relative;
        display: flex;
        align-items: center;
        cursor: pointer;
        padding: 10px 15px;
        border: 2px solid #e1e5e9;
        border-radius: 10px;
        transition: all 0.3s ease;
        background: #fafbfc;
      }
      
      .radio-option:hover {
        border-color: #3498db;
        background: rgba(52, 152, 219, 0.05);
      }
      
      .radio-option input[type='radio']:checked + label {
        color: #3498db;
        font-weight: 500;
      }
      
      /* Enhanced Buttons */
      .btn-container {
        display: flex;
        gap: 12px;
        margin: 20px 0;
        flex-wrap: wrap;
      }
      
      .custom-button {
        background: linear-gradient(135deg, #3498db, #2980b9);
        border: none;
        color: white;
        padding: 12px 24px;
        border-radius: 12px;
        font-weight: 500;
        font-size: 0.95rem;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        display: flex;
        align-items: center;
        gap: 8px;
        text-decoration: none;
      }
      
      .custom-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        background: linear-gradient(135deg, #2980b9, #21618c);
        color: white;
      }
      
      .clear-button {
        background: linear-gradient(135deg, #95a5a6, #7f8c8d);
        color: white;
        box-shadow: 0 4px 15px rgba(149, 165, 166, 0.3);
      }
      
      .clear-button:hover {
        background: linear-gradient(135deg, #7f8c8d, #6c7b7d);
        box-shadow: 0 6px 20px rgba(149, 165, 166, 0.4);
      }
      
      .download-button {
        background: linear-gradient(135deg, #f39c12, #e67e22);
        color: white;
        box-shadow: 0 4px 15px rgba(243, 156, 18, 0.3);
      }
      
      .download-button:hover {
        background: linear-gradient(135deg, #e67e22, #d35400);
        box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        color: white;
      }
      
      /* Enhanced Main Panel */
      .col-sm-8 {
        padding: 30px;
        background: white;
      }
      
      /* Enhanced Tabs */
      .nav-tabs {
        border-bottom: 2px solid #e1e5e9;
        margin-bottom: 25px;
      }
      
      .nav-tabs .nav-link {
        border: none;
        padding: 12px 24px;
        color: #6c757d;
        font-weight: 500;
        border-radius: 10px 10px 0 0;
        margin-right: 5px;
        transition: all 0.3s ease;
      }
      
      .nav-tabs .nav-link:hover {
        background: rgba(52, 152, 219, 0.1);
        color: #3498db;
      }
      
      .nav-tabs .nav-link.active {
        background: linear-gradient(135deg, #3498db, #2980b9);
        color: white;
        border-bottom: 2px solid #3498db;
      }
      
      /* Enhanced DataTable */
      .dataTables_wrapper {
        background: white;
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        border: 1px solid #e1e5e9;
      }
      
      .dataTables_wrapper .dataTables_length,
      .dataTables_wrapper .dataTables_filter {
        padding: 20px;
        background: #f8f9fa;
      }
      
      .dataTables_wrapper .dataTables_filter input {
        border: 2px solid #e1e5e9;
        border-radius: 8px;
        padding: 8px 12px;
        margin-left: 10px;
      }
      
      table.dataTable {
        border-collapse: separate;
        border-spacing: 0;
      }
      
      table.dataTable thead th {
        background: linear-gradient(135deg, #2c3e50, #34495e);
        color: white;
        font-weight: 600;
        padding: 15px 12px;
        border: none;
        text-align: center;
      }
      
      table.dataTable tbody td {
        padding: 12px;
        border-bottom: 1px solid #e1e5e9;
        vertical-align: middle;
      }
      
      table.dataTable tbody tr:hover {
        background: rgba(52, 152, 219, 0.05);
      }
      
      .dataTables_wrapper .dataTables_paginate {
        padding: 20px;
        background: #f8f9fa;
      }
      
      /* Enhanced Loading Overlay */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(44, 62, 80, 0.95);
        backdrop-filter: blur(5px);
        z-index: 9999;
        display: none;
      }
      
      .loading-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        background: white;
        padding: 50px;
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        min-width: 400px;
      }
      
      .spinner {
        border: 4px solid #e1e5e9;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 1s linear infinite;
        margin: 0 auto 25px auto;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      .progress-container {
        width: 100%;
        background-color: #e1e5e9;
        border-radius: 25px;
        margin: 25px 0;
        height: 30px;
        overflow: hidden;
      }
      
      .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #3498db, #2980b9);
        border-radius: 25px;
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 600;
        font-size: 14px;
      }
      
      .loading-text {
        font-size: 1.2rem;
        color: #2c3e50;
        margin-bottom: 10px;
        font-weight: 600;
      }
      
      .loading-detail {
        font-size: 0.95rem;
        color: #6c757d;
        margin-top: 15px;
      }
      
      /* Enhanced Status Messages */
      .status-card {
        background: linear-gradient(135deg, #e8f5e8, #d4edda);
        border: 1px solid #c3e6cb;
        border-radius: 12px;
        padding: 20px;
        margin: 20px 0;
        color: #155724;
        font-weight: 500;
      }
      
      /* Enhanced Help Text */
      .help-block {
        background: rgba(52, 152, 219, 0.1);
        border-left: 4px solid #3498db;
        padding: 15px;
        border-radius: 0 8px 8px 0;
        margin: 15px 0;
        font-size: 0.9rem;
        color: #2c3e50;
      }
      
      /* Enhanced Plots */
      .plot-container {
        background: white;
        border-radius: 15px;
        padding: 20px;
        margin: 20px 0;
        box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        border: 1px solid #e1e5e9;
      }
      
      /* Responsive Design */
      @media (max-width: 768px) {
        .main-title {
          font-size: 2rem;
        }
        
        .btn-container {
          flex-direction: column;
        }
        
        .custom-button {
          justify-content: center;
        }
        
        .radio-group {
          flex-direction: column;
        }
      }
    ")),
    
    # JavaScript for progress handling
    tags$script(HTML("
      Shiny.addCustomMessageHandler('show_loading', function(message) {
        document.getElementById('loading-overlay').style.display = 'block';
      });
      
      Shiny.addCustomMessageHandler('hide_loading', function(message) {
        document.getElementById('loading-overlay').style.display = 'none';
      });
      
      Shiny.addCustomMessageHandler('update_progress', function(message) {
        var progressBar = document.getElementById('progress-bar');
        var loadingText = document.getElementById('loading-text');
        var loadingDetail = document.getElementById('loading-detail');
        
        if (progressBar) {
          progressBar.style.width = message.percentage + '%';
          progressBar.textContent = message.percentage + '%';
        }
        if (loadingText && message.text) {
          loadingText.textContent = message.text;
        }
        if (loadingDetail && message.detail) {
          loadingDetail.textContent = message.detail;
        }
      });
    "))
  ),
  
  # Loading overlay
  div(id = "loading-overlay", class = "loading-overlay",
      div(class = "loading-content",
          div(class = "spinner"),
          div(id = "loading-text", class = "loading-text", "Processing articles..."),
          div(class = "progress-container",
              div(id = "progress-bar", class = "progress-bar", style = "width: 0%;", "0%")
          ),
          div(id = "loading-detail", class = "loading-detail", "Starting...")
      )
  ),
  
  # Enhanced Header
  div(class = "main-header",
      h1(class = "main-title", 
         icon("dna"), " PubMed Central Analytics"),
      p(class = "main-subtitle", 
        "Extract and analyze submission & acceptance dates from scientific publications")
  ),
  
  sidebarLayout(
    sidebarPanel(
      div(class = "sidebar-section",
          h4(icon("upload"), "Input Data"),
          textAreaInput("pmid_list", 
                        "Enter PMIDs or PMCIDs:",
                        placeholder = "Enter PubMed IDs (PMIDs) or PMC IDs\ne.g., 12345678\nPMC7654321\n\nOne ID per line",
                        height = "140px"),
          
          div(class = "radio-group",
              div(class = "radio-option",
                  radioButtons("id_type", "ID Type:",
                               choices = c("PMID" = "pmid", 
                                           "PMCID" = "pmcid"),
                               selected = "pmid",
                               inline = TRUE))
          )
      ),
      
      div(class = "sidebar-section",
          h4(icon("cogs"), "Actions"),
          div(class = "btn-container",
              actionButton("extract_button", 
                           HTML("<i class='fa fa-calendar'></i> Extract Dates"), 
                           class = "custom-button"),
              
              actionButton("clear_button", 
                           HTML("<i class='fa fa-eraser'></i> Clear"), 
                           class = "custom-button clear-button")
          ),
          
          downloadButton("download_data", 
                         HTML("<i class='fa fa-download'></i> Download Results"), 
                         class = "custom-button download-button")
      ),
      
      div(class = "sidebar-section",
          h4(icon("info-circle"), "Information"),
          div(class = "help-block",
              p(strong("Note:"), "This app extracts received (submission) and accepted dates from PubMed Central articles."),
              p("â€¢ Not all articles contain these dates"),
              p("â€¢ PMC articles must be open access for full text extraction"),
              p("â€¢ Processing may take a few moments per article")
          )
      )
    ),
    
    mainPanel(
      tabsetPanel(
        id = "main_tabs",
        tabPanel("ðŸ“Š Results", 
                 br(),
                 DTOutput("results_table"),
                 br(),
                 div(class = "status-card",
                     textOutput("status_message"))),
        
        tabPanel("ðŸ“ˆ Statistics",
                 br(),
                 div(class = "plot-container",
                     plotOutput("review_time_hist")),
                 
                 div(class = "plot-container",
                     plotOutput("time_trend")),
                 
                 div(class = "plot-container",
                     verbatimTextOutput("stats_summary")))
      )
    )
  )
)

# Server logic (keeping the same functionality)
server <- function(input, output, session) {
  
  # Reactive values to store results
  results <- reactiveVal(data.frame(
    PMID = character(),
    PMCID = character(),
    Title = character(),
    Journal = character(),
    Year = integer(),
    Date_Received = as.Date(character()),
    Date_Accepted = as.Date(character()),
    Review_Days = integer(),
    stringsAsFactors = FALSE
  ))
  
  # Observador para el botÃ³n Clear
  observeEvent(input$clear_button, {
    # Limpiar el Ã¡rea de texto
    updateTextAreaInput(session, "pmid_list", value = "")
    
    # Limpiar los datos de las tablas reseteando el reactiveVal
    results(data.frame(
      PMID = character(),
      PMCID = character(),
      Title = character(),
      Journal = character(),
      Year = integer(),
      Date_Received = as.Date(character()),
      Date_Accepted = as.Date(character()),
      Review_Days = integer(),
      stringsAsFactors = FALSE
    ))
    
    # Mostrar notificaciÃ³n
    showNotification("Input and tables cleared", type = "message", duration = 2)
  })
  
  # Function to show loading overlay
  showLoading <- function() {
    session$sendCustomMessage("show_loading", list())
  }
  
  # Function to hide loading overlay
  hideLoading <- function() {
    session$sendCustomMessage("hide_loading", list())
  }
  
  # Function to update progress
  updateProgress <- function(value, text = "", detail = "") {
    percentage <- round(value * 100)
    session$sendCustomMessage("update_progress", list(
      percentage = percentage,
      text = text,
      detail = detail
    ))
  }
  
  # Safe XML text extraction helper function
  safe_xml_text <- function(node) {
    if (inherits(node, "xml_missing") || length(node) == 0) {
      return(NA_character_)
    } else {
      return(xml2::xml_text(node))
    }
  }
  
  # Function to extract dates from PMC article
  extract_dates <- function(pmc_id) {
    tryCatch({
      # Ensure PMC ID format
      clean_pmc_id <- gsub("^PMC", "", pmc_id, ignore.case = TRUE)
      
      # Get the PMC article as XML
      pmc_article <- rentrez::entrez_fetch(db = "pmc", id = clean_pmc_id, rettype = "xml")
      xml_doc <- xml2::read_xml(pmc_article)
      
      # Extract article metadata
      pmid_node <- xml2::xml_find_first(xml_doc, "//article-id[@pub-id-type='pmid']")
      pmid <- safe_xml_text(pmid_node)
      
      title_node <- xml2::xml_find_first(xml_doc, "//article-title")
      title <- safe_xml_text(title_node)
      if (is.na(title)) {
        title_node <- xml2::xml_find_first(xml_doc, "//title-group/article-title")
        title <- safe_xml_text(title_node)
      }
      
      journal_node <- xml2::xml_find_first(xml_doc, "//journal-title")
      journal <- safe_xml_text(journal_node)
      if (is.na(journal)) {
        journal_node <- xml2::xml_find_first(xml_doc, "//journal-title-group/journal-title")
        journal <- safe_xml_text(journal_node)
      }
      
      year_node <- xml2::xml_find_first(xml_doc, "//pub-date[@pub-type='epub']//year | //pub-date[@pub-type='ppub']//year | //pub-date//year")
      pub_year <- if (!inherits(year_node, "xml_missing") && length(year_node) > 0) {
        as.integer(safe_xml_text(year_node))
      } else {
        NA_integer_
      }
      
      # Initialize dates
      received_date <- as.Date(NA)
      accepted_date <- as.Date(NA)
      
      # Extract dates from history
      date_nodes <- xml2::xml_find_all(xml_doc, "//history/date")
      
      for (node in date_nodes) {
        date_type <- xml2::xml_attr(node, "date-type")
        
        # Extract date components
        year_node <- xml2::xml_find_first(node, ".//year")
        month_node <- xml2::xml_find_first(node, ".//month")
        day_node <- xml2::xml_find_first(node, ".//day")
        
        year_val <- safe_xml_text(year_node)
        month_val <- safe_xml_text(month_node)
        day_val <- safe_xml_text(day_node)
        
        # Skip if any component missing
        if (any(is.na(c(year_val, month_val, day_val))) || any(c(year_val, month_val, day_val) == "")) {
          next
        }
        
        # Convert to integers
        tryCatch({
          year_int <- as.integer(year_val)
          month_int <- as.integer(month_val)
          day_int <- as.integer(day_val)
          
          # Validate date components
          if (is.na(year_int) || is.na(month_int) || is.na(day_int) ||
              year_int < 1900 || year_int > 2030 ||
              month_int < 1 || month_int > 12 ||
              day_int < 1 || day_int > 31) {
            next
          }
          
          # Create date
          parsed_date <- as.Date(paste(year_int, month_int, day_int, sep = "-"))
          
          # Assign based on date type
          if (!is.null(date_type)) {
            if (date_type == "received") {
              received_date <- parsed_date
            } else if (date_type == "accepted") {
              accepted_date <- parsed_date
            }
          }
        }, error = function(e) {
          # Skip this date if parsing fails
          next
        })
      }
      
      # Validate date logic
      if (!is.na(received_date) && !is.na(accepted_date)) {
        if (accepted_date < received_date) {
          showNotification(
            paste0("Warning: Invalid dates for PMC", clean_pmc_id, " - Acceptance before submission"),
            type = "warning"
          )
          # Keep the dates but mark as suspicious
        }
      }
      
      # Calculate review time
      review_days <- NA_integer_
      if (!is.na(received_date) && !is.na(accepted_date)) {
        review_days <- as.integer(difftime(accepted_date, received_date, units = "days"))
        
        # Sanity check for unrealistic review times
        if (!is.na(review_days) && (review_days < 0 || review_days > 3650)) {
          showNotification(
            paste0("Warning: Unusual review time for PMC", clean_pmc_id, ": ", review_days, " days"),
            type = "warning"
          )
        }
      }
      
      return(data.frame(
        PMID = if(is.na(pmid) || pmid == "") NA_character_ else pmid,
        PMCID = paste0("PMC", clean_pmc_id),
        Title = if(is.na(title) || title == "") paste("Article PMC", clean_pmc_id) else title,
        Journal = journal,
        Year = pub_year,
        Date_Received = received_date,
        Date_Accepted = accepted_date,
        Review_Days = review_days,
        stringsAsFactors = FALSE
      ))
      
    }, error = function(e) {
      showNotification(
        paste0("Error processing PMC", pmc_id, ": ", e$message),
        type = "error"
      )
      return(data.frame(
        PMID = NA_character_,
        PMCID = paste0("PMC", gsub("^PMC", "", pmc_id, ignore.case = TRUE)),
        Title = paste("Error fetching PMCID:", pmc_id),
        Journal = NA_character_,
        Year = NA_integer_,
        Date_Received = as.Date(NA),
        Date_Accepted = as.Date(NA),
        Review_Days = NA_integer_,
        stringsAsFactors = FALSE
      ))
    })
  }
  # Convert PMID to PMCID
  convert_pmid_to_pmcid <- function(pmid) {
    tryCatch({
      summary_result <- rentrez::entrez_summary(db = "pubmed", id = pmid)
      
      if ("articleids" %in% names(summary_result) && !is.null(summary_result$articleids)) {
        pmcid_entry <- summary_result$articleids[summary_result$articleids$idtype == "pmcid", ]
        
        if (nrow(pmcid_entry) > 0) {
          # Obtener el valor del PMCID y limpiarlo
          pmcid_raw <- pmcid_entry$value[1]
          
          # Limpiar el formato: remover "PMC-id: " y ";" y extraer solo los nÃºmeros
          pmcid_clean <- gsub("PMC-id:\\s*PMC|PMC|;", "", pmcid_raw, ignore.case = TRUE)
          pmcid_clean <- trimws(pmcid_clean)  # Remover espacios en blanco
          
          # Verificar que solo contenga nÃºmeros
          if (grepl("^[0-9]+$", pmcid_clean)) {
            return(pmcid_clean)
          } else {
            # Si no es solo nÃºmeros, intentar extraer nÃºmeros usando regex
            numbers_only <- gsub("[^0-9]", "", pmcid_raw)
            if (nchar(numbers_only) > 0) {
              return(numbers_only)
            }
          }
        }
      }
      return(NA_character_)
    }, error = function(e) {
      showNotification(paste("Error converting PMID", pmid, ":", e$message), type = "warning")
      return(NA_character_)
    })
  }
  
  # Process IDs when Extract button is clicked
  observeEvent(input$extract_button, {
    req(input$pmid_list)
    
    # Parse input IDs
    ids <- unlist(strsplit(input$pmid_list, "[\r\n]+"))
    ids <- trimws(ids)
    ids <- ids[nzchar(ids)]
    
    if (length(ids) == 0) {
      showNotification("Please enter at least one valid ID", type = "error")
      return()
    }
    
    # Show loading overlay
    showLoading()
    updateProgress(0, "Processing articles...", "Starting...")
    
    # Initialize results dataframe
    result_df <- data.frame(
      PMID = character(),
      PMCID = character(),
      Title = character(),
      Journal = character(),
      Year = integer(),
      Date_Received = as.Date(character()),
      Date_Accepted = as.Date(character()),
      Review_Days = integer(),
      stringsAsFactors = FALSE
    )
    
    # Process each ID
    for (i in seq_along(ids)) {
      current_id <- ids[i]
      progress_value <- (i - 1) / length(ids)
      updateProgress(progress_value, "Processing articles...", paste("Processing", current_id, "(", i, "of", length(ids), ")"))
      
      # Get PMCID based on input type
      pmcid <- if (input$id_type == "pmid") {
        convert_pmid_to_pmcid(current_id)
      } else {
        gsub("^PMC", "", current_id, ignore.case = TRUE)
      }
      # Skip if we couldn't get a valid PMCID
      if (is.na(pmcid) || pmcid == "") {
        result_row <- data.frame(
          PMID = if(input$id_type == "pmid") current_id else NA_character_,
          PMCID = if(input$id_type == "pmcid") current_id else NA_character_,
          Title = "ID not found or no PMCID available",
          Journal = NA_character_,
          Year = NA_integer_,
          Date_Received = as.Date(NA),
          Date_Accepted = as.Date(NA),
          Review_Days = NA_integer_,
          stringsAsFactors = FALSE
        )
        result_df <- rbind(result_df, result_row)
        next
      }
      
      # Extract dates from PMC article
      date_info <- extract_dates(pmcid)
      
      # Add original PMID if we're using PMIDs and it's missing from the fetched data
      if (input$id_type == "pmid" && (is.na(date_info$PMID) || date_info$PMID == "")) {
        date_info$PMID <- current_id
      }
      
      # Add to results
      result_df <- rbind(result_df, date_info)
      
      # Small delay to prevent overwhelming the API
      Sys.sleep(0.1)
    }
    
    # Final progress update
    updateProgress(1, "Completed!", paste("Processed", length(ids), "articles"))
    
    # Store results
    results(result_df)
    
    # Hide loading after a brief delay
    Sys.sleep(1)
    hideLoading()
    
    # Show notification
    showNotification(paste("Processed", nrow(result_df), "articles"), type = "message")
  })
  
  # Display results table
  output$results_table <- renderDT({
    df <- results()
    if(nrow(df) == 0) {
      return(NULL)
    }
    datatable(df, 
              options = list(pageLength = 10, 
                             autoWidth = TRUE,
                             scrollX = TRUE),
              rownames = FALSE) %>%
      formatDate(columns = c("Date_Received", "Date_Accepted"), method = "toLocaleDateString")
  })
  
  # Status message showing stats
  output$status_message <- renderText({
    df <- results()
    if (nrow(df) == 0) {
      return("No results yet. Enter PubMed IDs and click 'Extract Dates'.")
    }
    
    with_dates <- sum(!is.na(df$Date_Received) & !is.na(df$Date_Accepted))
    pct <- if (nrow(df) > 0) round(100 * with_dates / nrow(df)) else 0
    
    paste0(with_dates, " out of ", nrow(df), " articles (", pct, "%) have both submission and acceptance dates.")
  })
  
  # Download handler
  output$download_data <- downloadHandler(
    filename = function() {
      paste("pubmed_dates_extraction_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".csv", sep = "")
    },
    content = function(file) {
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  # Histogram of review times
  output$review_time_hist <- renderPlot({
    df <- results()
    
    if (nrow(df) == 0) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No data available", size = 6) +
               theme_void())
    }
    
    df_complete <- df %>% filter(!is.na(Review_Days) & Review_Days >= 0)
    
    if (nrow(df_complete) == 0) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No review time data available", size = 6) +
               theme_void())
    }
    
    median_val <- median(df_complete$Review_Days, na.rm = TRUE)
    
    ggplot(df_complete, aes(x = Review_Days)) +
      geom_histogram(binwidth = 30, fill = "steelblue", color = "white", alpha = 0.7) +
      labs(title = "Distribution of Review Times",
           x = "Review Time (Days)",
           y = "Number of Articles") +
      theme_minimal() +
      geom_vline(xintercept = median_val, linetype = "dashed", color = "red", size = 1) +
      annotate("text", 
               x = median_val + max(df_complete$Review_Days) * 0.1, 
               y = Inf, 
               label = paste("Median:", median_val, "days"),
               color = "red", hjust = 0, vjust = 1)
  })
  
  # Time trend of review times
  output$time_trend <- renderPlot({
    df <- results()
    
    if (nrow(df) == 0) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "No data available", size = 6) +
               theme_void())
    }
    
    df_complete <- df %>% 
      filter(!is.na(Review_Days) & !is.na(Year) & Review_Days >= 0) %>%
      group_by(Year) %>%
      summarize(
        Median_Days = median(Review_Days, na.rm = TRUE),
        Mean_Days = mean(Review_Days, na.rm = TRUE),
        Count = n(),
        .groups = 'drop'
      )
    
    if (nrow(df_complete) <= 1) {
      return(ggplot() + 
               annotate("text", x = 0.5, y = 0.5, label = "Not enough data for time trend", size = 6) +
               theme_void())
    }
    
    ggplot(df_complete, aes(x = Year)) +
      geom_line(aes(y = Median_Days, color = "Median"), size = 1) +
      geom_point(aes(y = Median_Days, color = "Median"), size = 3) +
      geom_line(aes(y = Mean_Days, color = "Mean"), size = 1, linetype = "dashed") +
      geom_point(aes(y = Mean_Days, color = "Mean"), size = 3) +
      geom_text(aes(y = Median_Days, label = Count), vjust = -1, size = 3) +
      scale_color_manual(name = "Measure", values = c("Median" = "blue", "Mean" = "red")) +
      theme_minimal() +
      labs(title = "Review Time Trend by Publication Year",
           subtitle = "Numbers indicate count of articles per year",
           x = "Publication Year",
           y = "Days from Submission to Acceptance") +
      scale_x_continuous(breaks = scales::pretty_breaks())
  })
  # Summary statistics
  output$stats_summary <- renderPrint({
    df <- results()
    
    if (nrow(df) == 0) {
      cat("No data available\n")
      return()
    }
    
    cat("Summary of Review Times (in days):\n\n")
    
    df_complete <- df %>% filter(!is.na(Review_Days) & Review_Days >= 0)
    
    if (nrow(df_complete) == 0) {
      cat("No complete review time data available\n")
      return()
    }
    
    # Overall statistics
    cat("Overall Statistics:\n")
    cat("Number of articles with complete date information:", nrow(df_complete), "\n")
    cat("Mean review time:", round(mean(df_complete$Review_Days, na.rm = TRUE), 1), "days\n")
    cat("Median review time:", median(df_complete$Review_Days, na.rm = TRUE), "days\n")
    cat("Minimum review time:", min(df_complete$Review_Days, na.rm = TRUE), "days\n")
    cat("Maximum review time:", max(df_complete$Review_Days, na.rm = TRUE), "days\n\n")
    
    # By journal (if we have enough data)
    journals_with_multiple <- df_complete %>%
      count(Journal) %>%
      filter(n > 1 & !is.na(Journal)) %>%
      pull(Journal)
    
    if (length(journals_with_multiple) > 0) {
      cat("Review Times by Journal (for journals with multiple articles):\n")
      journal_stats <- df_complete %>%
        filter(Journal %in% journals_with_multiple) %>%
        group_by(Journal) %>%
        summarize(
          Count = n(),
          Median = median(Review_Days, na.rm = TRUE),
          Mean = round(mean(Review_Days, na.rm = TRUE), 1),
          Min = min(Review_Days, na.rm = TRUE),
          Max = max(Review_Days, na.rm = TRUE),
          .groups = 'drop'
        ) %>%
        arrange(desc(Count))
      
      print(as.data.frame(journal_stats))
    }
  })
}

# Run the app
shinyApp(ui = ui, server = server)

